@inject IJSRuntime Js
@implements IDisposable

<div class="game-grid">
    @if (Games == null || Games.Count == 0)
    {
        <div class="empty-state">No games yet. Create or open a file to begin.</div>
    }
    else
    {
        @foreach (var game in Games)
        {
            var title = EditorState.GetGameDisplayTitle(game);
            var gameId = game.GameId;
            var imageUrl = GetImageUrl(gameId);
            var isFailed = IsFailed(gameId);
            var imageSrc = isFailed ? "assets/failed_cover_fetch.webp" : imageUrl;
            var isLoading = IsLoading(gameId);
            <button type="button" class="game-tile" data-game-id="@gameId"
                    @onclick="() => OnGameSelected.InvokeAsync(game)">
                <div class="game-image-frame">
                    @if (!string.IsNullOrWhiteSpace(imageUrl))
                    {
                        <!--suppress HtmlDeprecatedAttribute -->
                        <img class="game-tile-image @(isLoading ? "loading" : "")" src="@imageSrc"
                             alt="@title" @onload="() => OnImageLoaded(gameId)" @onerror="() => OnImageError(gameId)"/>
                    }
                    else
                    {
                        <img class="game-tile-image @(isLoading ? "loading" : "")" src="assets/unknown_game_cover.webp"
                             alt="Unknown cover art"/>
                    }
                    @if (isLoading)
                    {
                        <div class="game-image-loading-bar"></div>
                    }
                </div>
                <div class="game-tile-body">
                    <div class="game-tile-title">@title</div>
                    @if (!string.IsNullOrWhiteSpace(game.GameId))
                    {
                        <div class="game-tile-subtitle">@game.GameId</div>
                    }
                </div>
            </button>
        }
    }
</div>

@code {
    [Parameter] public IReadOnlyList<R4Game>? Games { get; set; }
    [Parameter] public EventCallback<R4Game> OnGameSelected { get; set; }
    [Parameter] public Func<R4Game, Task<string?>>? ImageUrlSelector { get; set; }
    private readonly Dictionary<string, ImageRequestState> _imageTasks = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, R4Game> _gamesById = new(StringComparer.OrdinalIgnoreCase);
    private DotNetObjectReference<GameGridView>? _dotNetRef;

    protected override async Task OnParametersSetAsync()
    {
        if (Games == null || ImageUrlSelector == null)
        {
            _imageTasks.Clear();
            _gamesById.Clear();
            return;
        }

        _gamesById.Clear();
        foreach (var game in Games)
        {
            if (string.IsNullOrWhiteSpace(game.GameId))
                continue;

            _gamesById[game.GameId] = game;
        }

        var currentIds = new HashSet<string>(_gamesById.Keys, StringComparer.OrdinalIgnoreCase);
        foreach (var gameId in _imageTasks.Keys.ToList().Where(gameId => !currentIds.Contains(gameId)))
            _imageTasks.Remove(gameId);

        await Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _dotNetRef ??= DotNetObjectReference.Create(this);
        await Js.InvokeVoidAsync("r4eLazyImages.observeAll", _dotNetRef);
    }

    [JSInvokable]
    public Task NotifyVisible(string gameId)
    {
        if (string.IsNullOrWhiteSpace(gameId) || _imageTasks.ContainsKey(gameId) || !_gamesById.TryGetValue(gameId, out var game))
            return Task.CompletedTask;

        _imageTasks[gameId] = new ImageRequestState(LoadImageAsync(game));
        return InvokeAsync(StateHasChanged);
    }

    private async Task<string?> LoadImageAsync(R4Game game)
    {
        if (ImageUrlSelector == null) return null;

        _ = Task.Delay(TimeSpan.FromSeconds(10)).ContinueWith(_ => InvokeAsync(StateHasChanged));
        var url = await ImageUrlSelector(game);
        await InvokeAsync(StateHasChanged);
        return url;
    }

    private string? GetImageUrl(string? gameId)
    {
        if (string.IsNullOrWhiteSpace(gameId))
            return null;

        if (_imageTasks.TryGetValue(gameId, out var entry) && entry.Task.IsCompletedSuccessfully)
            return entry.Task.Result;

        return null;
    }

    private bool IsFailed(string? gameId)
    {
        if (string.IsNullOrWhiteSpace(gameId))
            return false;

        return _imageTasks.TryGetValue(gameId, out var entry) && entry.HasError;
    }

    private bool IsLoading(string? gameId)
    {
        if (string.IsNullOrWhiteSpace(gameId))
            return false;

        if (!_imageTasks.TryGetValue(gameId, out var entry))
            return false;

        return !entry.IsLoaded && DateTime.UtcNow - entry.StartedAt < TimeSpan.FromSeconds(10);
    }

    private Task OnImageLoaded(string gameId)
    {
        if (string.IsNullOrWhiteSpace(gameId) || !_imageTasks.TryGetValue(gameId, out var entry) || entry.IsLoaded)
            return Task.CompletedTask;

        entry.IsLoaded = true;
        return InvokeAsync(StateHasChanged);
    }

    private Task OnImageError(string gameId)
    {
        if (string.IsNullOrWhiteSpace(gameId) || !_imageTasks.TryGetValue(gameId, out var entry) || entry.HasError)
            return Task.CompletedTask;

        entry.HasError = true;
        entry.IsLoaded = true;
        return InvokeAsync(StateHasChanged);
    }

    private sealed class ImageRequestState(Task<string?> task)
    {
        public Task<string?> Task { get; } = task;
        public DateTime StartedAt { get; } = DateTime.UtcNow;
        public bool IsLoaded { get; set; }
        public bool HasError { get; set; }
    }

    public void Dispose()
    {
        _dotNetRef?.Dispose();
    }

}
