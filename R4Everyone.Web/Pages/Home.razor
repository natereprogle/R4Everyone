@page "/"
@implements IDisposable
@inject EditorState Editor
@inject ViewportService Viewport
@inject IJSRuntime Js
@inject ToastService Toasts
@inject XmlDataService Xml;
@using System.Xml.Linq

<PageTitle>R4Everyone</PageTitle>

@if (!_isDesktop)
{
    <div class="desktop-warning">
        <div class="card shadow-sm">
            <div class="card-body">
                <h1 class="h4 mb-2">Desktop required</h1>
                <p class="mb-0">This app is designed for desktop. Please open it on a desktop browser.</p>
            </div>
        </div>
    </div>
}
else
{
    <div class="app-shell">
        <AppHeaderBar FileName="@Editor.LoadedFileName" HasLoadedFile="Editor.HasLoadedFile" IsDirty="Editor.IsDirty"
                      IsValid="Editor.IsValid" Errors="Editor.ValidationErrors"/>

        <div class="app-body container-fluid">
            <div class="row h-100 g-3">
                <div class="col-lg-2 h-100 d-flex flex-column gap-3">
                    <FileControlsPanel CanSave="CanSave" OnNew="OnNewFile" OnOpen="OnOpenFileSelected"
                                       OnSave="SaveAsync"/>

                    <ActionsPanel CanAddGame="true"
                                  CanRemoveGame="CanRemoveGame"
                                  IsValid="Editor.IsValid"
                                  Errors="Editor.ValidationErrors"
                                  OnAddGame="AddGame"
                                  OnRemoveGame="RemoveGame"/>
                </div>

                <div class="col-lg-10 h-100">
                    <GameGridView Games="Editor.Database?.Games ?? []" OnGameSelected="OpenGameModal"
                                  ImageUrlSelector="OnRenderGame"/>
                </div>
            </div>
        </div>

        <GameEditorModal IsOpen="IsGameModalOpen"
                         Game="_modalGame"
                         MasterCodes="MasterCodes"
                         CheatCodeText="@CheatCodeText"
                         OnClose="@CloseGameModal"
                         OnGameIdInput="OnGameIdInput"
                         OnGameTitleInput="OnGameTitleInput"
                         OnGameChecksumInput="OnGameChecksumInput"
                         OnGameEnabledChanged="OnGameEnabledChanged"
                         OnMasterCodeInput="OnMasterCodeInput"
                         OnRomFileSelected="OnRomFileSelected"
                         OnFolderTitleInput="OnFolderTitleInput"
                         OnFolderDescriptionInput="OnFolderDescriptionInput"
                         OnFolderOneHotChanged="OnFolderOneHotChanged"
                         OnCheatTitleInput="OnCheatTitleInput"
                         OnCheatDescriptionInput="OnCheatDescriptionInput"
                         OnCheatEnabledChanged="OnCheatEnabledChanged"
                         OnCheatCodeInput="OnCheatCodeInput"/>
    </div>
}

@code {
    private bool _isDesktop = true;
    private bool _isGameModalOpen;
    private R4Game? _modalGame;

    private bool IsGameModalOpen => _isGameModalOpen && _modalGame != null;

    private bool CanSave => Editor.HasLoadedFile && Editor.IsDirty && Editor.IsValid;
    private bool CanRemoveGame => Editor.SelectionKind == SelectionKind.Game;

    private string[] MasterCodes => GetMasterCodes();

    private string CheatCodeText => Editor.SelectedCheat == null
        ? string.Empty
        : FormatCheatBlocks(Editor.GetCheatCodeBlocks(Editor.SelectedCheat).Select(ToBigEndianHex));

    protected override void OnInitialized()
    {
        Editor.StateChanged += HandleStateChanged;
        Viewport.ViewportChanged += HandleViewportChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Viewport.InitializeAsync();
            _isDesktop = Viewport.IsDesktop;
            StateHasChanged();
        }
    }

    private void HandleStateChanged()
    {
        if (_isGameModalOpen && _modalGame != null)
        {
            var games = Editor.Database?.Games;
            if (games == null || !games.Contains(_modalGame))
            {
                _isGameModalOpen = false;
                _modalGame = null;
            }
        }

        InvokeAsync(StateHasChanged);
    }

    private void HandleViewportChanged()
    {
        _isDesktop = Viewport.IsDesktop;
        InvokeAsync(StateHasChanged);
    }

    private void OpenGameModal(R4Game game)
    {
        _modalGame = game;
        _isGameModalOpen = true;
        Editor.Select(SelectionInfo.ForGame(game));
    }

    private async Task<string> OnRenderGame(R4Game game)
    {
        if (string.IsNullOrWhiteSpace(game.GameId))
        {
            return string.Empty;
        }

        var gameElement = await Xml.FindGameByIdAsync("assets/dstdb.xml", game.GameId);
        if (gameElement is null)
        {
            return string.Empty;
        }

        var languages = GetLanguageCandidates(gameElement);
        foreach (var url in languages.Select(lang => $"https://art.gametdb.com/ds/coverM/{lang}/{game.GameId}.jpg"))
        {
            if (await ImageExistsAsync(url))
            {
                return url;
            }
        }

        return string.Empty;
    }

    private static List<string> GetLanguageCandidates(XElement gameElement)
    {
        var localeLanguages = gameElement.Elements("locale")
            .Select(locale => locale.Attribute("lang")?.Value)
            .Where(lang => !string.IsNullOrWhiteSpace(lang))
            .Select(lang => lang!)
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToList();

        var languages = localeLanguages;
        if (languages.Count == 0)
        {
            var languageText = (string?)gameElement.Element("languages");
            if (!string.IsNullOrWhiteSpace(languageText))
            {
                languages = languageText
                    .Split(',', StringSplitOptions.RemoveEmptyEntries)
                    .Select(lang => lang.Trim())
                    .Where(lang => !string.IsNullOrWhiteSpace(lang))
                    .Distinct(StringComparer.OrdinalIgnoreCase)
                    .ToList();
            }
        }

        if (languages.Count == 0)
        {
            return [];
        }

        var enIndex = languages.FindIndex(lang => lang.Equals("EN", StringComparison.OrdinalIgnoreCase));
        if (enIndex <= 0) return languages;
        var enValue = languages[enIndex];
        languages.RemoveAt(enIndex);
        languages.Insert(0, enValue);

        return languages;
    }

    private async Task<bool> ImageExistsAsync(string url)
    {
        try
        {
            return await Js.InvokeAsync<bool>("r4eImages.check", url);
        }
        catch
        {
            return false;
        }
    }

    private void CloseGameModal()
    {
        if (_modalGame != null)
        {
            Editor.Select(SelectionInfo.ForGame(_modalGame));
        }
        else
        {
            Editor.Deselect();
        }

        _isGameModalOpen = false;
        _modalGame = null;
    }

    private void AddGame()
    {
        _isGameModalOpen = false;
        _modalGame = null;
        Editor.AddGame();
    }


    private void RemoveGame()
    {
        if (Editor.SelectionKind != SelectionKind.Game || Editor.SelectedGame == null)
        {
            return;
        }

        var removedGame = Editor.SelectedGame;
        Editor.RemoveSelected();

        if (!_isGameModalOpen || !ReferenceEquals(removedGame, _modalGame)) return;
        _isGameModalOpen = false;
        _modalGame = null;
    }


    private string[] GetMasterCodes()
    {
        var game = Editor.SelectedGame ?? _modalGame;
        if (game == null)
        {
            return [];
        }

        return Editor.GetMasterCodeText(game)
            .Select(ToBigEndianHex)
            .ToArray();
    }

    private void OnGameIdInput(ChangeEventArgs args)
    {
        Editor.UpdateGameId(args.Value?.ToString() ?? string.Empty);
    }

    private void OnGameTitleInput(ChangeEventArgs args)
    {
        Editor.UpdateGameTitle(args.Value?.ToString() ?? string.Empty);
    }

    private void OnGameChecksumInput(ChangeEventArgs args)
    {
        Editor.UpdateGameChecksum(args.Value?.ToString() ?? string.Empty);
    }

    private void OnGameEnabledChanged(ChangeEventArgs args)
    {
        Editor.UpdateGameEnabled(args.Value is bool and true);
    }

    private void OnMasterCodeInput(int index, ChangeEventArgs args)
    {
        var game = Editor.SelectedGame ?? _modalGame;
        if (game == null)
        {
            return;
        }

        var input = args.Value?.ToString() ?? string.Empty;
        var sanitized = SanitizeHexInput(input, 8);
        Editor.UpdateMasterCode(game, index, ToLittleEndianHex(sanitized));
    }

    private void OnFolderTitleInput(ChangeEventArgs args)
    {
        Editor.UpdateFolderTitle(args.Value?.ToString() ?? string.Empty);
    }

    private void OnFolderDescriptionInput(ChangeEventArgs args)
    {
        Editor.UpdateFolderDescription(args.Value?.ToString() ?? string.Empty);
    }

    private void OnFolderOneHotChanged(ChangeEventArgs args)
    {
        Editor.UpdateFolderOneHot(args.Value is true);
        if (args.Value is true)
            Toasts.ShowWarning("'One Hot' only allows one cheat in a folder to be enabled at a time, and so all cheats except the first 'Enabled' one (if any) have been disabled. If this was unintended, disable One Hot and re-enable your cheats.");
    }

    private void OnCheatTitleInput(ChangeEventArgs args)
    {
        Editor.UpdateCheatTitle(args.Value?.ToString() ?? string.Empty);
    }

    private void OnCheatDescriptionInput(ChangeEventArgs args)
    {
        Editor.UpdateCheatDescription(args.Value?.ToString() ?? string.Empty);
    }

    private void OnCheatEnabledChanged(ChangeEventArgs args)
    {
        Editor.UpdateCheatEnabled(args.Value is true);
    }

    private void OnCheatCodeInput(string value)
    {
        if (Editor.SelectedCheat == null)
        {
            return;
        }

        var blocks = ParseCheatRows(value)
            .Select(ToLittleEndianHex)
            .ToList();
        Editor.UpdateCheatBlocks(Editor.SelectedCheat, blocks);
    }

    private async Task OnRomFileSelected(InputFileChangeEventArgs args)
    {
        var game = Editor.SelectedGame ?? _modalGame;
        if (game == null)
        {
            return;
        }

        var file = args.File;
        // Allows files of any size to be open, since we're only reading the first 512 bytes, and it's local anyway.
        await using var stream = file.OpenReadStream(int.MaxValue);
        var buffer = new byte[512];
        var bytesRead = await stream.ReadAsync(buffer);

        if (bytesRead > 0)
        {
            var data = buffer.Take(bytesRead).ToArray();
            Editor.ApplyRomMetadata(data);
        }
    }

    private async Task OnOpenFileSelected(InputFileChangeEventArgs args)
    {
        Toasts.ShowInfo("Opening file...");
        var file = args.File;
        await using var stream = file.OpenReadStream(int.MaxValue);
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        ms.Position = 0;
        await Editor.LoadAsync(ms, file.Name);
    }

    private void OnNewFile()
    {
        Editor.NewFile();
        Toasts.ShowInfo("New file created. Ready to edit!");
    }

    private async Task SaveAsync()
    {
        if (!CanSave)
        {
            Toasts.ShowError("Please review any errors before saving");
            return;
        }

        var bytes = await Editor.BuildSaveBytesAsync();
        if (bytes == null)
        {
            return;
        }

        Toasts.ShowInfo("Beginning download...");
        var fileName = string.IsNullOrWhiteSpace(Editor.LoadedFileName) ? "cheats.dat" : Editor.LoadedFileName;
        await Js.InvokeVoidAsync("downloadFile", fileName, "application/octet-stream", bytes);
        Editor.MarkSaved();
    }

    public void Dispose()
    {
        Editor.StateChanged -= HandleStateChanged;
        Viewport.ViewportChanged -= HandleViewportChanged;
    }

    private static string ToBigEndianHex(string value)
    {
        return ReverseEndianHex(value);
    }

    private static string ToLittleEndianHex(string value)
    {
        return ReverseEndianHex(value);
    }

    private static string ReverseEndianHex(string value)
    {
        if (value.Length != 8)
        {
            return value;
        }

        return string.Concat(
            value.AsSpan(6, 2),
            value.AsSpan(4, 2),
            value.AsSpan(2, 2),
            value.AsSpan(0, 2));
    }

    private static string SanitizeHexInput(string input, int maxLength)
    {
        if (string.IsNullOrEmpty(input))
        {
            return string.Empty;
        }

        var buffer = new List<char>(Math.Min(input.Length, maxLength));
        foreach (var ch in input)
        {
            if (!IsHexChar(ch))
            {
                continue;
            }

            buffer.Add(char.ToUpperInvariant(ch));
            if (buffer.Count == maxLength)
            {
                break;
            }
        }

        return new string(buffer.ToArray());
    }

    private static List<string> ParseCheatRows(string input)
    {
        if (string.IsNullOrEmpty(input))
        {
            return [];
        }

        var normalized = input.Replace("\r\n", "\n").Replace("\r", "\n");
        var rows = new List<string>();
        if (normalized.Contains('\n'))
        {
            var lines = normalized.Split('\n');
            foreach (var line in lines)
            {
                var chars = line.Where(IsHexChar)
                    .Select(char.ToUpperInvariant)
                    .ToArray();

                if (chars.Length == 0)
                {
                    continue;
                }

                var chunks = SplitIntoChunks(chars);
                AppendRows(rows, chunks);
            }
        }
        else
        {
            var chars = normalized.Where(IsHexChar)
                .Select(char.ToUpperInvariant)
                .ToArray();

            if (chars.Length == 0)
            {
                return [];
            }

            var chunks = SplitIntoChunks(chars);
            AppendRows(rows, chunks);
        }

        if (rows.Count % 2 != 0)
        {
            rows.Add(string.Empty);
        }

        return rows;
    }

    private static string FormatCheatBlocks(IEnumerable<string> blocks)
    {
        var formattedBlocks = blocks.ToList();
        if (formattedBlocks.Count == 0)
        {
            return string.Empty;
        }

        if (formattedBlocks.Count % 2 != 0)
        {
            formattedBlocks.Add(string.Empty);
        }

        var lines = new List<string>();
        for (var i = 0; i < formattedBlocks.Count; i += 2)
        {
            var left = formattedBlocks[i];
            var right = formattedBlocks[i + 1];
            if (string.IsNullOrEmpty(left) && string.IsNullOrEmpty(right))
            {
                continue;
            }

            if (string.IsNullOrEmpty(right))
            {
                lines.Add(left);
                continue;
            }

            lines.Add($"{left} {right}");
        }

        return string.Join("\n", lines);
    }

    private static List<string> SplitIntoChunks(char[] chars)
    {
        var chunks = new List<string>();
        for (var i = 0; i < chars.Length; i += 8)
        {
            var length = Math.Min(8, chars.Length - i);
            chunks.Add(new string(chars, i, length));
        }

        return chunks;
    }

    private static void AppendRows(List<string> rows, List<string> chunks)
    {
        for (var i = 0; i < chunks.Count; i += 2)
        {
            rows.Add(chunks[i]);
            rows.Add(i + 1 < chunks.Count ? chunks[i + 1] : string.Empty);
        }
    }

    private static bool IsHexChar(char ch)
    {
        return ch is >= '0' and <= '9' || ch is >= 'a' and <= 'f' || ch is >= 'A' and <= 'F';
    }

}
